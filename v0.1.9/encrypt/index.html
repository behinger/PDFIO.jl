<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Encryption in PDF · PDFIO</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDFIO</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../README/">PDFIO</a></li><li><a class="toctext" href="../arch/">Architecture and Design</a></li><li class="current"><a class="toctext" href>Encryption in PDF</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Encryption-Methods-1">Encryption Methods</a></li><li><a class="toctext" href="#What-can-be-encrypted?-1">What can be encrypted?</a></li><li><a class="toctext" href="#Process-of-Encryption-1">Process of Encryption</a></li></ul></li><li><a class="toctext" href="../digsig/">Digital Signatures</a></li><li><a class="toctext" href="../">API Reference</a></li><li><a class="toctext" href="../LICENSE/">PDFIO License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Encryption in PDF</a></li></ul><a class="edit-page" href="https://github.com/sambitdash/PDFIO.jl/blob/master/docs/src/encrypt.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Encryption in PDF</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Encryption-in-PDF-1" href="#Encryption-in-PDF-1">Encryption in PDF</a></h1><p>PDF files can be encrypted across the complete file or selectively for specific sections. The encryption scheme used in PDFs can be based on the PDF standard specification or can be controlled by custom schemes developed by the PDF creators. These flexibilities can be achieved by the following security handlers of the PDF processors.</p><ol><li>Password based Standard Security Handlers</li><li>PKI certificate based Public Key Security Handlers</li><li>Crypt filters that can be used for specific streams in a PDF document</li></ol><h1><a class="nav-anchor" id="Encryption-Methods-1" href="#Encryption-Methods-1">Encryption Methods</a></h1><h2><a class="nav-anchor" id="What-can-be-encrypted?-1" href="#What-can-be-encrypted?-1">What can be encrypted?</a></h2><p>Not all information in a PDF file is encrypted. Only the streams and strings that tend to have informational content are encrypted. Integers, booleans or any such information that is only structural are not encrypted. Document metadata that can be used for search and other information extraction process need not be encrypted in a PDF document. Secondly, care is always taken such that content is not encrypted multiple number of times. For example, only one encryption filter is permitted in a stream. Once such a filter is specifically chosen for a stream the document default filters are not applicable to such streams. Strings that are part of object streams that are encrypted are excluded from further encryption.</p><h2><a class="nav-anchor" id="Process-of-Encryption-1" href="#Process-of-Encryption-1">Process of Encryption</a></h2><p>PDF encryption is based on a symmetric key algorithm based on older RC4 or AES-128 bit schemes or modern AES-256 bit encryption algorithms. These methods require a 40, 128 or 256 bit key be used to encrypt or decrypt the PDF document. Since, the key has to be kept inside the PDF document, password based approaches or PKI Certificate based approaches are taken to secure the encryption key. One encryption key is used per crypt filter and once the API successfully manages to decrypt the key it can be caches securedly for subsequent operations.</p><h3><a class="nav-anchor" id="Standard-Security-Handlers-1" href="#Standard-Security-Handlers-1">Standard Security Handlers</a></h3><p>Standard security handler provides a flexible mechanism of securing the file encryption key using two passwords. Namely, document open password (user password) and document permission (owner password). A document may not have a user password. In such cases, providing a blank string as input can open the document. However, it must be noted that the file encryption key is still used in these cases as well. And such document is not equivalent to a document without passwords. Owner password defaults to the user password if it&#39;s not explicitly set. The older RC4 or AES-128bit encryption schemes were based on user password being used to encrypt the file encryption key and owner password being used to encrypt the user password. However, the modern AES-256bit system utilizes a hashed based validation than encrypting one password with the other. However, either the owner password or the user password can be used to retrieve the document encryption key.</p><h3><a class="nav-anchor" id="Public-Key-Security-Handlers-1" href="#Public-Key-Security-Handlers-1">Public Key Security Handlers</a></h3><p>Public key security handler utilizes the public key of a digital certificate to encrypt the file encryption key that can be only be decrypted by a specific set of recipients whose public key was used to encrypt the file encryption keys. Again, the document can be decrypted only by the recipient on successful production of the private key of the certificate.</p><h3><a class="nav-anchor" id="Permissions-1" href="#Permissions-1">Permissions</a></h3><p>PDF specification provides permissions for users different from that of the owners. Owners have no usage restriction while users can be limited by certain permissions. The permissions are expected to be enforced by the reader applications. Once decrypted there is no way to technically encfore limitations. In the context of the API, we do not restrict any APIs but expect the consumer of the APIs to enforce the permissions as desired. The permission can be found in the security handlers keys dictionary mapped to each crypt filter. The permissions can be accessed by:</p><p><code>cosdoc.secHandler.keys[&lt;Crypt Filter Name&gt;][1]</code></p><p>When the user password is used to authenticate the document permission entry is cached. However, when an owner password is used the value cached is <code>0xffffffff</code> signifying all the permissions are available.</p><h3><a class="nav-anchor" id="Prompting-for-Access-1" href="#Prompting-for-Access-1">Prompting for Access</a></h3><p>As discussed earlier, not all PDF content may be encrypted. Hence, the prompting for password or token to decrypt (in case of PKI security handler) can occur when such a need is felt. When a particular piece of content requires decryption in case of a standard security handler a <code>Base.getpass()</code> based challenge is thrown on the <code>stdout</code>. However, this may not be a convenient way to programatically utilize and API. The following APIs provide additional keyword <code>access=predicate</code> as a way to override the default behavior. Following is an example of a <code>pdDocOpen</code> call utilizing a fixed password as input.</p><pre><code class="language-none">doc = pdDocOpen(&quot;file.pdf&quot;, access=()-&gt;Base.SecretBuffer!(copy(b&quot;password&quot;)))</code></pre><p>The same interface can be used with the method <code>cosDocOpen</code> as well. </p><h3><a class="nav-anchor" id="Keeping-Access-Secured-1" href="#Keeping-Access-Secured-1">Keeping Access Secured</a></h3><p>It must have come to you as a surprise the usage of such a complex predicate for passing a simple password. However, <code>String</code> objects being immutable, it&#39;s never a desired in security applications to have secured information lying in the memory indefinitely as <code>String</code>s. While <code>Vector{UInt8}</code> objects get reclaimed, the underlying memory is never overwritten leaving out secured information in the memory to be harvested with crash dumps, pagefile or memory walks. <code>Base.SecureBuffer</code> comes handy in such cases as it clears off the underlying memory to <code>zero</code> or provides a <code>shred!</code> method that can be utilized to clear off the memory on demand. The predicate must return a <code>Base.SecretBuffer</code> object to be consumed by the security handler.</p><h3><a class="nav-anchor" id="Caching-of-the-File-Encryption-Key-1" href="#Caching-of-the-File-Encryption-Key-1">Caching of the File Encryption Key</a></h3><p>Just as much like the password, the computed file encyption key is a crucial piece of information that is cached in the memory with the security handler object. Although, it resides at: <code>cosdoc.secHandler.keys[&lt;Crypt Filter Name&gt;][2]</code>. It&#39;s encrypted with a symmetric key and nonce generated during the initialization of the secuirty handler and cached to a temporary file. When a decryption task is to be carried out the key and nonce are secured from the file and used to decrypt the file encryption key. As soon as the task is over the file encryption keys are <code>shred!</code>ed by a <code>SecureBuffer</code> interface. Thus a random dump of memory may neither have the password nor the file encryption key resident in memory. With the API being open source we do not expect to provide any protection against debugging. </p><h3><a class="nav-anchor" id="PKI-Security-Handler-1" href="#PKI-Security-Handler-1">PKI Security Handler</a></h3><p>PKI security handler can be used to decrypt PDF documents if needed. The handler will be invoked when needed to decrypt data very similar to the standard security handler. The default method provides capabilities to decrypt the document using a PKCS#12 (.p12) file as a keystore. However, the default behavior can be easily overwritten by providing your own access function. The default code looks like below:</p><pre><code class="language-none">function get_digital_id()
    p12file = &quot;&quot;
    while !isfile(p12file)
        p12file =
            prompt(&quot;Select the PCKS#12 (.p12) certificate for the recepient&quot;)
    end
    p12pass = getpass(&quot;Enter the password to open the PKCS#12 (.p12) file&quot;)
    return shred!(x-&gt;read_pkcs12(p12file, x), p12pass)
end

doc = pdDocOpen(&quot;file.pdf&quot;, access=get_digital_id)</code></pre><p>The functionality has been developed with <code>OpenSSL</code>. OpenSSL <code>ENGINE</code> interface can be used to implement another version of <code>get_digital_id</code> method using a <code>PKCS#11</code> based interface to enable HSM or hardware tokens as certificate stores.</p><footer><hr/><a class="previous" href="../arch/"><span class="direction">Previous</span><span class="title">Architecture and Design</span></a><a class="next" href="../digsig/"><span class="direction">Next</span><span class="title">Digital Signatures</span></a></footer></article></body></html>
