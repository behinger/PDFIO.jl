<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Architecture and Design · PDFIO</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDFIO</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../README/">PDFIO</a></li><li class="current"><a class="toctext" href>Architecture and Design</a><ul class="internal"><li><a class="toctext" href="#PDF-specification-ISO-32000-1-and-ISO-32000-2-1">PDF specification ISO-32000-1 and ISO-32000-2</a></li><li><a class="toctext" href="#PDF-Components-1">PDF Components</a></li></ul></li><li><a class="toctext" href="../encrypt/">Encryption in PDF</a></li><li><a class="toctext" href="../digsig/">Digital Signatures</a></li><li><a class="toctext" href="../">API Reference</a></li><li><a class="toctext" href="../LICENSE/">PDFIO License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Architecture and Design</a></li></ul><a class="edit-page" href="https://github.com/sambitdash/PDFIO.jl/blob/master/docs/src/arch.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Architecture and Design</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Architecture-and-Design-1" href="#Architecture-and-Design-1">Architecture and Design</a></h1><p>The design philosophy of PDF documents can be understood by the article written by John Warnock, founding CEO of Adobe Systems, called the <a href="http://www.planetpdf.com/planetpdf/pdfs/warnock_camelot.pdf">Camelot</a> paper. Unlike, PostScript which is a Turing complete programming language, PDF is a file format. The operators in PDF do not leave a side effect on an execution stack, that can be further exploited by the subsequent operators. While one need not have full understanding of PostScript to understand PDF general complexities of a <em>page description language (PDL)</em>  like PostScript are seen in PDFs as well. Here are a few simple scenarios of similarities and dissimilarities of PDF vs PostScript are presented here. This will help you understand the design principles of PDF.</p><ol><li><strong>Execution Order and Page</strong>: PostScript is an execution engine. It would execute the code as the operators are received and results are left on the execution stack as side-effects. Depending on the device rendering capabilities, PostScript would load the rendered output to the device on a call of <code>showpage</code>. PDF does not have the flexibility of execution of a programming language. Generally, PDF content are organized as page objects. The content to be rendered and the resources (fonts and images) are associated with a page. Moreover, the content is rendered in the order in which they appear. Unless otherwise specified, the ink is considered opaque. Thus a content rendered later may overwrite the content rendered earlier if there is an overlap.</li><li><strong>Content Order vs. Reading Order</strong>: PDLs focus on final look and feel of the output and not the reading order of the text or artifacts. For example, fonts tend to be an expensive resource to load at least under low memory conditions. Once loaded an execution engine may like to render all the content utilizing the font resource earlier than render the artifacts in the reading order. A document optimized for such purpose will tend to organize all text utilizing a specific fonts at one place.</li><li><strong>Content Objects vs. Non-Content Objects</strong>: Without getting much into the definition complexities, we can state a content leaves an artifact on a page and is rendered. While some other objects may affect the user interface or provide additional document metadata information and they are not rendered on a PDF page. One example will be PDF outlines or navigation links. They only are shown on a user interface and not on a rendered page.</li><li><strong>Random vs. Sequential Access</strong>: PDF files are designed for random access of the document. You can get to any page and access the contents of the page. While PostScript was not designed for that purpose. It typically will be loaded once and executed.</li></ol><h2><a class="nav-anchor" id="PDF-specification-ISO-32000-1-and-ISO-32000-2-1" href="#PDF-specification-ISO-32000-1-and-ISO-32000-2-1">PDF specification ISO-32000-1 and ISO-32000-2</a></h2><p>The API is developed around PDF specification, notably around ISO-32000-1, that can be downloaded from <a href="https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdfs/PDF32000_2008.pdf">Adobe</a>. Some attempts have been made to consider certain features of PDF-2.0 (<a href="https://www.iso.org/standard/63534.html">ISO-32000-2</a>). However, the attempts have been made with draft versions of the specification. The final version of the specification has not been reviewed for the implementations. Hence, the support is only experimental.</p><p>The API derives heavily from the PDF specification and tries to be as compliant to the specification as practical. Any significant discrepancies in the APIs have to be compared with the PDF specification for clarification and accuracy. The API is an extension to the PDF specification. Hence, it&#39;s recommended the users of the API refer to the specification as well for a clearer understanding of the working of the API. Where a feature is best understood from the specification, reference to the specification will be provided than elaborating it in the API documentation.</p><h2><a class="nav-anchor" id="PDF-Components-1" href="#PDF-Components-1">PDF Components</a></h2><p>PDF specification identifies the following components of a file. For details about the components please refer to the Chapter-7 of the PDF specification 1.7.</p><ol><li>Objects</li><li>File Structure</li><li>Document Structure</li><li>Content Objects</li></ol><p>Based on the components being used the API is divided into two layers.</p><h3><a class="nav-anchor" id="COS-Layer-1" href="#COS-Layer-1">COS Layer</a></h3><h4><a class="nav-anchor" id="Objects-1" href="#Objects-1">Objects</a></h4><p>Carousel Object System (COS) is an object representation for both simple and composite objects. <a href="../#PDFIO.Cos.CosObject"><code>CosObject</code></a> is the highest level abstraction that all the objects inherit from. The objects supported in PDF are:</p><h5><a class="nav-anchor" id="Simple-1" href="#Simple-1">Simple</a></h5><ul><li><a href="../#PDFIO.Cos.CosNull"><code>CosNull</code></a> - A singleton object representing a <code>null</code> in PDF. </li><li><a href="../#PDFIO.Cos.CosBoolean"><code>CosBoolean</code></a> Values: <code>CosTrue</code> or <code>CosFalse</code></li><li><a href="../#PDFIO.Cos.CosNumeric"><code>CosNumeric</code></a>(abstract) Concrete Types: <a href="../#PDFIO.Cos.CosInt"><code>CosInt</code></a>, <a href="../#PDFIO.Cos.CosFloat"><code>CosFloat</code></a></li><li><a href="../#PDFIO.Cos.CosString"><code>CosString</code></a>(abstract) - String in PDF is a collection of binary data and does not represent a meaningful text unless it&#39;s associated with a specific font and encoding. For clarity, please refer to the section 7.3.4 and 7.9.3 of the PDF specification. <code>Strings</code> can be represented as hexadecimal notations or direct byte values. They are internally knows as <code>CosXString</code> or <code>CosLiteralString</code> respectively. The consumers of the APIs do not have to be affected by such distinctions.</li><li><a href="../#PDFIO.Cos.CosName"><code>CosName</code></a> - Very similar to <code>Symbol</code> objects of Julia. </li></ul><h5><a class="nav-anchor" id="Composite-1" href="#Composite-1">Composite</a></h5><ul><li><a href="../#PDFIO.Cos.CosArray"><code>CosArray</code></a> - an array collection of <code>CosObjects</code>. </li><li><a href="../#PDFIO.Cos.CosDict"><code>CosDict</code></a> - an associative collection of name value pairs where names are of type <code>CosName</code> and values can be of any <code>CosObject</code></li><li><a href="../#PDFIO.Cos.CosStream"><code>CosStream</code></a> - very similar to <code>CosDict</code>, but the dictionary is followed by arbitrary binary data. This data can be in a compressed and encoded form by a series of algorithms known as filters.</li></ul><h4><a class="nav-anchor" id="File-Structure-1" href="#File-Structure-1">File Structure</a></h4><p>PDF file structure provides how the objects are arranged in a PDF file. PDF is designed to be accessed in a random access order. Some of the objects in PDF like fonts can be referred from multiple page objects. To address these concerns objects are provided reference identifiers and mappings are provided from various locations in the PDF files. Moreover, to reduce the size of the files, the objects are put inside stream containers and can be compressed. Access to a specific object reference may need several lookups before the actual object can be traced. All these lead to a fairly complex arrangement of objects. <a href="../#PDFIO.Cos.CosDoc"><code>CosDoc</code></a> wraps all the object reference schemes and provide a simplified API called <a href="../#PDFIO.Cos.cosDocGetObject"><code>cosDocGetObject</code></a> and simplifies object look up. Thus any PDF object can be classified into the following forms based on how they are represented in a document:</p><ul><li><em>Direct Objects</em> - Direct objects are defined where they are referred or used.</li><li><em>Indirect Objects</em> - Indirect objects have reference identifiers, there location in a PDF document is described through a Object Reference identifier.</li></ul><pre><code class="language-PDF">146 0 obj # Object Refence (146, 0) can be indirect object
&lt;&lt;
  	/Subject	(AU-B Australian Documents) # CosString is a direct object
  	/CreationDate	(27 May 1999 11: 1) 
  	/Title	(199479714D)
  	/ModDate	(D:19990527113911)
  	/Author	(IP Australia)
  	/Keywords	(Patents)
  	/Creator	(HPA image bureau 1998-1999)
  	/Producer	(HPA image bureau 1998-1999)
&gt;&gt;
endobj</code></pre><p>Normally, direct and indirect objects can be used interchangeably. But, there are certain cases where the specification dictates objects will be either direct or indirect. For example, objects used inside of a page content can be only direct objects. In such cases, names are used instead of object identifiers. Resources like fonts in a page content are names and not object identifiers.</p><h4><a class="nav-anchor" id="Document-Structure-1" href="#Document-Structure-1">Document Structure</a></h4><p>There are additional structures in the document that are commonly used inside a PDF document. Some of them are:</p><ul><li><p><em>Document Catalog Dictionary</em> - The root object from where PDF document reading begins. For example, this has the reference to a page tree.</p><pre><code class="language-PDF">154 0 obj
&lt;&lt;
	/Type	/Catalog
	/Pages	152 0 R
&gt;&gt;
endobj</code></pre></li><li><p><em>Page Tree</em> - Pages in a document can be arranged in a generic tree structure. While for better access binary search trees are the recommended approach there is no hard rule and document creators are free to define the structure in any manner that&#39;s relevant to them.</p><pre><code class="language-PDF">152 0 obj
&lt;&lt;
	/Type	/Pages
	/Kids	[147 0 R 148 0 R 149 0 R 150 0 R 151 0 R ]
	/Count	30
&gt;&gt;
endobj</code></pre></li></ul><p>In the above example, <code>Kids</code>  represents a direct <code>CosArray</code> that contains  reference object identifiers <code>(147 0), (148 0),  (149 0),  (150 0),  (151 0)</code>.</p><ul><li><em>Name Dictionary</em> - Associates various named components to other hierarchical structures in a document. Typically, represented as an object referenced in the document catalog.</li></ul><h4><a class="nav-anchor" id="Is-COS-Layer-Sufficient-for-PDF-parsing?-1" href="#Is-COS-Layer-Sufficient-for-PDF-parsing?-1">Is COS Layer Sufficient for PDF parsing?</a></h4><p>Since COS layer represents the objects, document structure and file structure, is it sufficient to parse a PDF file? The answer to this question is mostly yes. You can virtually do anything with a PDF file using only methods defined in the COS layer.</p><ul><li>But, this will enforce one to follow the PDF specification in totality for extracting any information from a PDF file. But, that can overwhelm one to implement any significant task with PDF files.</li><li>Secondly, COS layer does not expose the <code>Contents</code> objects of the PDF pages. Hence, no rendering related activity can be carried out in this layer.</li></ul><p>A PD Layer is developed to create functional PDF tasks as well as to render PDF content objects. However, when a functional implementation is not available in a PD Layer, COS Layer can be used to implement a functionality with low level APIs. Most of the PD Layer implementations utilize methods from the COS Layer. However, a good COS layer method implementation should never refer the a methods of the PD layer.</p><h4><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h4><p>Extracting files embedded inside a PDF document is not currently available as a PD Layer functionality. However, the same has been achieved using COS layer functions. The code is available in the automated test cases as well.</p><pre><code class="language-julia">function pdfhlp_extract_doc_attachment_files (filename, dir=tempdir())
  	file=rsplit(filename, &#39;/&#39;,limit=2)
  	filenm=file[end]
  	dirpath=joinpath(dir,filenm)
  	isdir(dirpath) &amp;&amp; rm(dirpath;force=true, recursive=true)
  	mkdir(dirpath)	
  	doc=pdDocOpen(filename)
  	cosDoc=pdDocGetCosDoc(doc)
  	try
    	npage= pdDocGetPageCount(doc)
    	for i=1:npage
      		page = pdDocGetPage(doc, i)
      		cospage = pdPageGetCosObject(page)
      		annots = cosDocGetObject(cosDoc, cospage, cn&quot;Annots&quot;)
      		annots === CosNull &amp;&amp; continue
      	end
      	annotsarr=get(annots)
      	for annot in annotsarr
        	annotdict = cosDocGetObject(cosDoc, annot)
        	subtype = get(annotdict, cn&quot;Subtype&quot;)
        	if (subtype == cn&quot;FileAttachment&quot;)
          		filespec = cosDocGetObject(cosDoc, annotdict, cn&quot;FS&quot;)
          		ef = get(filespec, cn&quot;EF&quot;)
          		filename = get(filespec, cn&quot;F&quot;) 
                #UF could be there as well.
          		stmref = get(ef, cn&quot;F&quot;)
          		stm = cosDocGetObject(cosDoc, stmref)
          		bufstm = get(stm)
          		buf = read(bufstm)
          		close(bufstm)
          		path = joinpath(dirpath, get(filename))
          		write(path, buf)
        	end
      	end
  	finally
 		pdDocClose(doc)
  	end
end</code></pre><p>As can be seen, this requires one to understand the PDF specification to skim through the PDF objects to extract the file from the relevant object where it&#39;s embedded.</p><h4><a class="nav-anchor" id="Limitations-1" href="#Limitations-1">Limitations</a></h4><p>While the implementation of the COS layer is fairly elaborate, PDF security handlers are not implemented as part of this API. Hence, this implementation is not effective where a document is encrypted with passwords. Such documents typically have all the string and stream objects encrypted using document passwords. Hence, cannot be read by <code>PDFIO</code>.</p><h3><a class="nav-anchor" id="PD-Layer-1" href="#PD-Layer-1">PD Layer</a></h3><p>Understanding the scope of COS layer leaves out the following functionalities for the PD layer.</p><ol><li>Extract and render the Contents in of a PDF page. This ensures the contents are organized in a hierarchical grouping, that can be used for rendering of the content. Rendering is used here in a generic context and not confined to painting on a raster device. For example, extracting document text can also be considered as a rendering task. <code>pdPageExtractText</code> is an apt example of the same.</li><li>Provide functional tasks to PDF document access. A few of such functionalities are:<ul><li>Getting the page count in a document</li><li>Finding labels in a document page</li><li>Extracting outlines defined in the document</li><li>Extracting document metadata information</li><li>Validation of signatures in a PDF document</li><li>Extracting fonts and font attributes</li></ul></li></ol><p>PD layer is an ever expanding layer. As newer functionality are implemented PD layer will introduce newer methods, that will enhance the library capabilities.</p><h4><a class="nav-anchor" id="Limitations-2" href="#Limitations-2">Limitations</a></h4><p>Although PD layer has been developed, PDF specification is quite vast. Functionalities currently exposed are mostly implemented to aid text extraction from document better. However, more advanced features can be added as and when needed to the APIs. Writing PDF output has not been implemented. When implemented, PD layer needs to be expanded for the same.</p><h3><a class="nav-anchor" id="Common-Data-Structures-(CD-Layer)-1" href="#Common-Data-Structures-(CD-Layer)-1">Common Data Structures (CD Layer)</a></h3><p>PDF is a platform independent file format. This requires, certain features that needs to be abstracted to support multitude of platforms. Here are some object types where certain special handing of data may be needed:</p><ul><li><em>Strings</em> - For example, text which are part of content objects can be  represented very well using <code>CosString</code> objects. But, PDF may have text that  do not associate a font or encoding thereof associated to string objects. In  such cases, unicode strings or PDF encoded strings are represented. PDF  encoding is a consistent representation of printable characters that can be  applied irrespective of platform where the file is used. This can be  considered as the default encoding of a PDF file.</li><li><em>Date and Time</em> - The PDF file may have creation time, modification time embedded in the document. Such data is represented as a string object. However, translating such time attributes to time objects for comparison is definitely essential.</li><li><em>File and File System</em> - Unix, Microsoft Windows, Mac OS X have their own file representations that may be different. Julia itself being a platform independent language caters directly to such needs.</li><li><em>Name tree and Number trees</em> - General purpose tree like data structures that hold a hierarchy based on name strings or numbers. Although, these objects are defined they are not exposed outside as they generally are used in the internal context of operations. An API user may not normally need to manipulate them.</li></ul><p>Now that you have some understanding of the PDF architecture you can refer to the <a href="../#API-Reference-1">API Reference</a> to understand the scope of each method and use them as needed for your applications. Please keep the PDF specification handy to understand the nuances of the APIs.</p><footer><hr/><a class="previous" href="../README/"><span class="direction">Previous</span><span class="title">PDFIO</span></a><a class="next" href="../encrypt/"><span class="direction">Next</span><span class="title">Encryption in PDF</span></a></footer></article></body></html>
